/**
\page CPFCMakeAPIDocs API Documentation

This page holds the documentation of the *CMake* functions that are provided to the
users of the *CPFCMake* package.


\section cpfAddPackageModule Module cpfAddCppPackage.cmake

This module provides the following functions.

- \ref cpfInitPackageProject
- \ref cpfAddCppPackage


\subsection cpfInitPackageProject cpfInitPackageProject()

\code 
cpfInitPackageProject(
    packageNameOut
    packageNameSpace
) 
\endcode

This function is called at the beginning of a packages *CMakeLists.txt* file.
This function calls the \c project() function to create the package-level project.
It automatically reads the version number of the package from the packages
git repository or a provided version file. It also reads the directory name
as the package name and returns it with parameter \c packageNameOut.

Parameter \c packageNameSpace is used in the following ways:

- CPFCMake assumes, that you use that namespace as the basic namespace for
all your C++ files. 
- The name is used as a namespace in the packages generated C++ version header file.
- As a namespace for the packages cmake target names.
- As a part of the packages export macro which must be 
prepended to all exported classes and functions in a library.
- The default package documentation page will generate a
documentation of that namespace.

\see \ref CIProjectAndPackageProjects


\subsection cpfAddCppPackage cpfAddCppPackage()

\code
cpfAddCppPackage(
    PACKAGE_NAME name
    [BRIEF_DESCRIPTION description]
    [LONG_DESCRIPTION description]
    [HOMEPAGE url]
    [MAINTAINER_EMAIL address]
    PACKAGE_NAMESPACE namespace
    TYPE [GUI_APP|CONSOLE_APP|LIB]
    [PUBLIC_HEADER header1 [header2 ...]]
    PRODUCTION_FILES file1 [file2 ...]
    [PUBLIC_FIXTURE_HEADER header1 [header2 ...]]
    [FIXTURE_FILES file1 [file2 ...]]
    [TEST_FILES file1 [file2 ...]]
    [LINKED_LIBRARIES target1 [target2 ...]]
    [LINKED_TEST_LIBRARIES target1 [target2 ...]]
    [PLUGIN_DEPENDENCIES 
        PLUGIN_DIRECTORY dir
        PLUGIN_TARGETS target1 [target2 ...]
        [PLUGIN_DIRECTORY ...] ...]
    [DISTRIBUTION_PACKAGES
        DISTRIBUTION_PACKAGE_CONTENT_TYPE [ CT_RUNTIME | CT_RUNTIME_PORTABLE excludedTargets | CT_DEVELOPER | SOURCES ]
        DISTRIBUTION_PACKAGE_FORMATS [7Z|TBZ2|TGZ|TXZ|TZ|ZIP|DEB] [format2 ...]
        [DISTRIBUTION_PACKAGE_FORMAT_OPTIONS 
            [SYSTEM_PACKAGES_DEB packageListString ]]
        [DISTRIBUTION_PACKAGE_CONTENT_TYPE ...] ...]
    [VERSION_COMPATIBILITY_SCHEME [ExactVersion] ]
    [ENABLE_ABI_API_COMPATIBILITY_CHECK_TARGETS bool]
    [GENERATE_PACKAGE_DOX_FILES]
)
\endcode

Adds a C++ package to a CPF project. The function provides a large list of options that allow 
defining the features that the CPF package should provide. 

A package consists of a main binary target that has the same name as the package and some helper binary targets for tests and test utilities.
Providing the function with optional arguments will switch on more of CPF's functionality like test-targets, code-analysis, packaging or
documentation generation.

\see \ref CPFCustomTargets


### Keyword Arguments ###

#### PACKAGE_NAME ####

The should be retrieved with the \ref cpfInitPackageProject function to make
sure that it is the name of the current source directory.
This will be used as the name of the main binary target of the package.

#### [BRIEF_DESCRIPTION] ####

A short description in one sentence about what the package does. This is included
in the generated documentation page of the package and in some distribution package
types.

#### [LONG_DESCRIPTION] ####

A longer description of the package. This is included
in the generated documentation page of the package and in some distribution package
types.

#### [HOMEPAGE] ####

A web address from where the source-code and/or the documentation of the package can be obtained.
This is required for Debian packages.

#### [MAINTAINER_EMAIL] ####

An email address under which the maintainers of the package can be reached.
This is required for Debian packages.

#### PACKAGE_NAMESPACE ####

\see cpfInitPackageProject

#### TYPE ####

The type of the main binary target of the package.

\c GUI_APP = Executable with switched of console. Use this for Qt applications with GUI; 
\c CONSOLE_APP = Console application; 
\c LIB = Library

#### PUBLIC_HEADER ####

All header files that declare functions or classes that are supposed to be
used by consumers of a library package. The public headers will automatically
be put into binary distribution packages, while header files in the \c PRODUCTION_FILES
are not included.

#### PRODUCTION_FILES ####

All files that belong to the production target. If the target is an executable, 
there should be a main.cpp that is used for the executable.

#### PUBLIC_FIXTURE_HEADER ####

All header files in the fixture library that are required by external clients of the library.
If the fixture library is only used by this package, this can be empty.

#### FIXTURE_FILES ####

All files that belong to the test fixtures target.

#### TEST_FILES ####

All files that belong to the test executable target.

#### LINKED_LIBRARIES ####

The names of the library targets that are linked to the main binary target.

#### LINKED_TEST_LIBRARIES ####

The names of the library targets that are linked to the test fixture library
and the test executable. Use this to specify dependencies of the test targets
that are not needed in the production code, like fixture libraries from other
packages.

#### [PLUGIN_DEPENDENCIES]...  ####

This keyword opens a sub-list of arguments that are used to define plugin dependencies of the package. 
Multiple PLUGIN_DEPENDENCIES sub-lists can be given to allow having multiple plugin subdirectories.

The plugin targets are shared libraries that are explicitly loaded by the packages executables and on which the
package has no link dependency. If a target in the list does not exist when the function is called,
it will be silently ignored. If a given target is an internal target, an artificial dependency between
the plugin target and the packages executables is created to make sure the plugin is compilation is up-to-date before the
executable is build.

Adding this options makes sure that the plugin library is build before the executable and copied besides it
in the \c PLUGIN_DIRECTORY.

Sub-Options:

\c PLUGIN_DIRECTORY: A directory relative to the packages executables in which the plugin libraries must be deployed so they are found by the executable.
This if often a \c plugins directory.

\c PLUGIN_TARGETS: The name of the targets that provide the plugin libraries.


####  [DISTRIBUTION_PACKAGES]... ####

This keyword opens a sub-list of arguments that are used to specify a list of packages that have the same content, but different formats.
The argument can be given multiple times, in order to define a variety of package formats and content types.
The argument takes two lists as sub-arguments. A distribution package is created for each combination of the
elements in the sub-argument lists.
For example: 
argument <code>DISTRIBUTION_PACKAGES DISTRIBUTION_PACKAGE_CONTENT_TYPE CT_RUNTIME_PORTABLE DISTRIBUTION_PACKAGE_FORMATS ZIP;7Z</code>
will cause the creation of a zip and a 7z archive that both contain the packages executables and all depended on shared libraries.
Adding another argument <code>DISTRIBUTION_PACKAGES DISTRIBUTION_PACKAGE_CONTENT_TYPE CT_RUNTIME DISTRIBUTION_PACKAGE_FORMATS DEB</code>
will cause the additional creation of a debian package that relies on external dependencies being provided by other packages.

Sub-Options:

\c DISTRIBUTION_PACKAGE_CONTENT_TYPE                

- <code>CT_RUNTIME</code>: The distribution-package contains the executables and shared libraries that are produced by this package.
This can be used for packages that either do not depend on any shared libraries or only on shared libraries that
are provided externally by the system.

- <code>CT_RUNTIME_PORTABLE listExcludedTargets</code>: The distribution-package will include the packages executables 
and shared libraries and all depended on shared libraries. This is useful for creating "portable" packages
that do not rely on any system provided shared libraries.
The CT_RUNTIME_PORTABLE keyword can be followed by a list of depended on targets that belong
to shared libraries that should not be included in the package, because they are provided by the system. 

- <code>CT_DEVELOPER</code>: The distribution-package will include all package binaries, header files and cmake config files for 
importing the package in another project. This content type is supposed to be used for binary library packages
that are used in other projects. Note that for msvc debug configurations the package will also include source files
to allow debugging into the package. The package does not include dependencies which are supposed to be imported
separately by consuming projects.

- <code>CT_SOURCES</code>: The distribution-package contains the files that are needed to compile the package.


\c DISTRIBUTION_PACKAGE_FORMATS

- <code>7Z |TBZ2 | TGZ | TXZ | TZ | ZIP</code>: Packs the distributed files into one of the following archive formats: .7z, .tar.bz2, .tar.gz, .tar.xz, tar.Z, .zip
- <code>DEB</code>: Creates a debian package .deb file. This will only be created when the dpkg tool is available.

\c DISTRIBUTION_PACKAGE_FORMAT_OPTIONS

A list of keyword arguments that contain further options for the creation of the distribution packages.

- <code>[SYSTEM_PACKAGES_DEB]</code>: This is only relevant when using the DEB package format. 
The option must be a string that contains the names and versions of the debian packages 
that provide the excluded shared libraries from the CT_RUNTIME option. E.g. "libc6 (>= 2.3.1-6), libc6 (< 2.4)"
on which the package depends.

####  [VERSION_COMPATIBILITY_SCHEME] ####

This option determines which versions of the package are can compatible to each other. This is only
of interest for shared library packages. For compatible versions it should be possible to replace
an older version with a newer one by simply replacing the library file or on linux by changing the symlink
that points to the used library. Not that it is still the developers responsibility to implement the
library in a compatible way. This option will only influence which symlinks are created, output file names
and the version.cmake files that are used to import the library.

\note Currently only <code>ExactVersion</code> scheme is available, so you do not need to set this option.

##### Schemes #####

- <code>ExactVersion</code>: This option means, that different versions of the library are not compatible.
This is the most simple scheme and relieves developers from the burdon of keeping things compatible.


####  [ENABLE_ABI_API_COMPATIBILITY_CHECK_TARGETS bool] ####

This option can be used to override the global CPF_ENABLE_ABI_API_COMPATIBILITY_CHECK_TARGETS setting.


####  [GENERATE_PACKAGE_DOX_FILES]  ####

If this option is given, the package will generate a standard package documentation .dox file.
The file contains the brief and long package description as well as some links to other generated
html content like test-coverage reports or abi-compatibility reports.


### Example ###

Here is an example of an \c CMakeLists.txt file for a library package.

\code{.unparsed}
# MyLib/CMakeLists.txt

include(cpfAddCppPackage)
include(cpfConstants)

set( PACKAGE_NAMESPACE myl )

set( briefDescription "My awsome library." )

set( longDescription 
"Here you can go on in length about how awsome your library is."
)

cpfInitPackageProject(
	PACKAGE_NAME
	${PACKAGE_NAMESPACE}
)

######################################### Define package files ######################################################
set( PACKAGE_PUBLIC_HEADERS
	MyFunction.h
)

set( PACKAGE_PRODUCTION_FILES
	MyFunction.cpp
    MyPrivateFunction.h
    MyPrivateFunction.cpp
)

set( PACKAGE_FIXTURE_FILES
	TestFixtures/MyFunction_fixtures.cpp
    TestFixtures/MyFunction_fixtures.h
)

set( PACKAGE_TEST_FILES
	Tests/MyFunction_tests.cpp
)

set(PACKAGE_LINKED_LIBRARIES
    Qt5::Core
    Qt5::Gui
)

set(PACKAGE_LINKED_TEST_LIBRARIES
	GMock::gmock
)

set( qtPlatformPlugins 
	PLUGIN_DIRECTORY 	platforms
	PLUGIN_TARGETS		Qt5::QWindowsIntegrationPlugin Qt5::QXcbIntegrationPlugin
)

set( myPlugin 
	PLUGIN_DIRECTORY 	plugins
	PLUGIN_TARGETS		MyPlugin
)

set( archiveDevPackageOptions
	DISTRIBUTION_PACKAGE_CONTENT_TYPE 	CT_DEVELOPER
	DISTRIBUTION_PACKAGE_FORMATS 		7Z
)

set( archiveUserPackageOptions
	DISTRIBUTION_PACKAGE_CONTENT_TYPE 	CT_RUNTIME
	DISTRIBUTION_PACKAGE_FORMATS 		ZIP
)

set( debianPackageOptions
	DISTRIBUTION_PACKAGE_CONTENT_TYPE	CT_RUNTIME Qt5::Core Qt5::Test Qt5::Gui_GL Qt5::QXcbIntegrationPlugin
	DISTRIBUTION_PACKAGE_FORMATS 		DEB
	DISTRIBUTION_PACKAGE_FORMAT_OPTIONS SYSTEM_PACKAGES_DEB "libqt5core5a, libqt5gui5" 
)

############################################## Add Package ###################################################
cpfAddCppPackage( 
	PACKAGE_NAME			${PACKAGE_NAME}
	PACKAGE_NAMESPACE		${PACKAGE_NAMESPACE}
	HOMEPAGE				"http://www.awsomelib.com/index.html"
	MAINTAINER_EMAIL		"hans@awsomelib.com"
	TYPE					LIB
	BRIEF_DESCRIPTION		${briefDescription}
	LONG_DESCRIPTION		${longDescription}
    PUBLIC_HEADER           ${PACKAGE_PUBLIC_HEADERS}
	PRODUCTION_FILES		${PACKAGE_PRODUCTION_FILES}
	FIXTURE_FILES			${PACKAGE_FIXTURE_FILES}
	TEST_FILES				${PACKAGE_TEST_FILES}
	LINKED_LIBRARIES		${PACKAGE_LINKED_LIBRARIES}
	LINKED_TEST_LIBRARIES	${PACKAGE_LINKED_TEST_LIBRARIES}
	PLUGIN_DEPENDENCIES		${qtPlatformPlugins}
    PLUGIN_DEPENDENCIES		${myPlugin}
	DISTRIBUTION_PACKAGES 	${archiveDevPackageOptions}
	DISTRIBUTION_PACKAGES 	${archiveUserPackageOptions}
	DISTRIBUTION_PACKAGES 	${debianPackageOptions}
)

\endcode


*/